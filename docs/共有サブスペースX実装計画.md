# 共有サブスペースX検証の実装計画

## 1. 全体方針

現在はPhase 2までの実装が完了し、モデルおよび損失モジュールが揃いました。


- 実験計画書で定義された仮説H1〜H4を検証するため、PyTorchベースの最小実装を整備する。
- 単一GPU環境で再現可能なパイプラインとして、データ生成、学習、評価、解析を一貫して自動化する。
- 開発は小さなモジュール単位で進め、各ステップでスモークテストとログ検証を行う。
- パッケージ管理には`uv`を採用し、`pyproject.toml`と`uv.lock`で依存関係とPythonバージョンを固定する。

## 2. 開発フェーズとマイルストーン
| フェーズ | 期間目安 | 主な成果物 |
| --- | --- | --- |
| Phase 0: 基盤整備 | Week 0–0.5 | uvベースの仮想環境、`src/`ディレクトリ構成、共通ユーティリティ |
| Phase 1: データ生成器 | Week 0.5–1 | プリミティブ実装、合成タスク生成、マルチホットラベル付与、単体テスト |
| Phase 2: モデルと損失 | Week 1–2 | ベースラインモデル、共有正則化、疎AE、補助ヘッドの統合 |
| Phase 3: 学習パイプライン | Week 2–2.5 | 学習ループ、チェックポイント、ロギング（TensorBoard/CSV） |
| Phase 4: 評価とfew-shot | Week 2.5–3 | ゼロショット評価、few-shot適応スクリプト、学習時間計測 |
| Phase 5: 表現解析 | Week 3 | CKA/Grassmann計算、疎特徴解析、可視化 |
| Phase 6: 図表と文書化 | Week 4 | 解析レポート、README/docs更新、再現手順 |

### Phase 0補足: uvを用いた基盤整備
- Python 3.11系を前提とし、`uv python install 3.11`でローカルにインタプリタを配置する。
- `pyproject.toml`に依存関係とプロジェクトメタデータを定義し、`uv init --package`で初期化を実施する。
- 仮想環境は`uv venv .venv`で作成し、以降のコマンドは`uv run`または`uv pip sync`を経由して実行する。
- CIでも`uv`を利用できるよう、`uv`インストール手順と`uv pip sync`の呼び出しをワークフローに追加する。

## 3. ディレクトリ構成案
```
mutual_concept_loss/
├── pyproject.toml
├── uv.lock
├── src/
│   ├── data/
│   │   ├── primitives.py
│   │   ├── generator.py
│   │   └── transforms.py
│   ├── models/
│   │   ├── encoder.py
│   │   ├── decoder.py
│   │   ├── bottleneck.py
│   │   └── adapters.py
│   ├── losses/
│   │   ├── task.py
│   │   ├── share.py
│   │   └── sparse_autoencoder.py
│   ├── analysis/
│   │   ├── cka.py
│   │   ├── grassmann.py
│   │   └── probes.py
│   ├── training/
│   │   ├── loop.py
│   │   ├── scheduler.py
│   │   └── evaluation.py
│   └── utils/
│       ├── logging.py
│       └── seed.py
├── scripts/
│   ├── train.py
│   ├── eval_zero_shot.py
│   ├── finetune_few_shot.py
│   └── analyze_representation.py
└── docs/
```

## 4. モジュール別実装計画
### 4.1 データ生成 (`src/data`)
1. **プリミティブ定義**：8×8グリッドを操作する関数群を実装。
   - 入力: Tensor[H, W, C]、パラメータ（例: 色、回転方向）。
   - 出力: 同形状テンソル。
   - ランダム化パラメータを`dataclass`で管理し、再現性のため乱数シードを受け取る。
2. **タスク合成器**:
   - 合成長1–2（学習）、長3（テスト）を生成。
   - サンプル構造: `{"input": grid_in, "target": grid_out, "primitives": multi_hot}`。
   - `torch.utils.data.Dataset`互換クラスを実装。
3. **データローダ**:
   - バッチ内で同一マルチホットラベルのサンプルをまとめる`GroupedBatchSampler`を作成。
   - バッファリングによりオンザフライ生成を効率化。
4. **テスト**:
   - 代表的プリミティブの入出力比較テスト。
   - ラベル分布とバリデーションセットの生成確認。

### 4.2 モデル (`src/models`)
1. **エンコーダ**:
   - 小型TransformerとGRUを共通インターフェイスで実装。
   - 入力グリッドをパッチ埋め込み（Conv2d）して系列化。
2. **ボトルネックと疎AE**:
   - 表現h（dim=128）を抽出し、疎AEでz（dim=k_sparse）を生成。
   - L1ターゲット活性率を制御するスケジューラを実装。
3. **デコーダ**:
   - 8×8グリッド再構成のための転置畳み込み or MLP。
4. **補助ヘッド**:
   - プリミティブ多ラベル分類用の線形層。
5. **LoRA/Adapter**:
   - few-shot用にbottleneck近傍の線形層へ挿入可能な軽量モジュールを実装。

### 4.3 損失 (`src/losses`)
1. **タスク損失**:
   - CEと1−IoUの切替を可能にする設定。
2. **共有正則化**:
   - バッチ内グループごとにPCAを計算し、射影行列距離を算出。
   - PCA結果の`detach`処理とEMA更新をオプションで提供。
3. **疎AE損失**:
   - 再構成MSEとL1ペナルティ。活性率の監視メトリクスを返す。
4. **損失マネージャ**:
   - `alpha, beta, gamma`をステップに応じてスケジュール可能に。

### 4.4 トレーニング (`src/training`)
1. **学習ループ**:
   - 1ステップごとにメトリクスを計算、`LightningLite`や独自ループで実装。
   - Mixed precisionと勾配クリッピングをサポート。
2. **ロギング**:
   - TensorBoard SummaryWriterとCSVロガーを併用。
   - 主要指標（損失、IoU、共有度、活性率）を可視化。
3. **チェックポイント**:
   - ベストval IoUで保存し、学習再開をサポート。
4. **評価スクリプト**:
   - ゼロショット検証：未見合成セットでのIoU/Accを記録。
   - Few-shot適応：LoRA/Adapter挿入 → 微調整 → パフォーマンスと到達ステップをログ。
5. **時間計測**:
   - `time.perf_counter()`でステップ時間、合計時間をログ。

### 4.5 解析 (`src/analysis`)
1. **CKA**:
   - バッチから表現を収集し、線形CKAを計算。
   - タスク×層のヒートマップを生成。
2. **Grassmann距離**:
   - PCA基底からの距離計算ユーティリティ。
3. **線形プローブ**:
   - 学習済み表現上でプリミティブ検出器を訓練し、転移性能を測定。
4. **疎特徴解析**:
   - zユニット活性の統計とプリミティブ出現の相関を出力。
   - 代表サンプルのグリッド可視化をPNG保存。

## 5. 検証とテスト
- **ユニットテスト**: `pytest`でデータ生成、損失計算、疎AEの前向き計算を確認。
- **統合テスト**: ミニバッチ（バッチサイズ2, ステップ5）で学習ループが動作することを確認。
- **再現性テスト**: 固定シードで2回学習し、主要指標のばらつきを記録。

## 6. ログ・結果管理
- `outputs/`配下に`runs/<timestamp>/`ディレクトリを作成し、以下を保存。
  - `config.yaml`: ハイパーパラメータと乱数シード。
  - `metrics.csv`: 学習・評価メトリクス。
  - `checkpoints/`: モデル重み。
  - `analysis/`: CKA行列、ヒートマップ画像、疎特徴可視化。
- 実験のメタデータは`docs/実験ログ.md`へ集約し、主要結果を追記。

## 7. リスク対応
- PCAの不安定性: グループサイズとEMA係数を設定値でチューニングし、失敗時はランダム射影へのフォールバック関数を用意。
- 過度な共有による性能低下: ハイパーパラメータスイープ自動化スクリプトを準備し、結果を比較できるよう`hydra`や`argparse`の設定を整理。
- 計算資源制約: `gradient_accumulation`と小型モデル設定を提供し、T4級GPUでも動作することを確認。

## 8. 文書化
- `README.md`に実行手順・主要スクリプトの説明を追加。
- READMEの環境構築手順には`uv`の導入方法と`uv pip sync`による依存関係解決を明記する。
- `docs/`フォルダにて、
  - 本実装計画（本書）。
  - 実験結果サマリー (`docs/results_summary.md`、Phase 4以降に作成)。
  - 解析レポート (`docs/analysis_report.md`)。
- 変更のたびに、設定値や手順の差分を記録。

## 9. 完了判定
- H1〜H4の評価指標が全て集計され、可視化が存在する。
- 実験スクリプトがシード固定で再現できることを確認済み。
- READMEとdocsが最新の実装に追随し、第三者が同等環境で再実行可能。
